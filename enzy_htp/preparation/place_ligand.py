"""Provides functionality for placing a ligand into a protein. All functionalty should be accessed through 
the place_ligand() function. No other function should be called directly by users. Allows for placement of 
ligands via one of the below methods:

    + alphafill: Uses the AlphaFill transplant algorithm to identify a location for a given ligand. Works best
    for common bi-molecular co-factors (i.e. SAM, ATP, etc). Assumes PDB style atom naming.
    
    + mole2: Uses cavities identified by the Mole2 software suite to identify possible locations for a given 
    Ligand. Ranks possible locations/orientations using supplied geomtry constraints. Works best for non-co-factor
    substrates. More neutral to atom naming than alphafill.

Author: Chris Jurich <chris.jurich@vanderbit.edu>
Date: 2023-09-14
"""
#TODO(CJ): update the documentation here
import json
from typing import List, Tuple, Dict, Set

from rdkit import Chem as _rchem
import numpy as np
import pandas as pd
import enzy_htp as eh
from pathlib import Path
from copy import deepcopy
from collections import defaultdict

from enzy_htp import interface, config
from enzy_htp.core import file_system as fs

from enzy_htp.core import _LOGGER

import enzy_htp.chemical as chem
from enzy_htp.structure import PDBParser, Structure, Ligand, Mol2Parser, Chain
from enzy_htp.structure.structure_constraint import StructureConstraint
from enzy_htp._interface import Mole2Cavity

from .align_ligand import align_ligand


def place_ligand(stru : Structure,
                    ligand_chain:str,
                    ligand_idx:int,
                    method: str = 'alphafill',
                    work_dir: str = None,
                    constraints: List[StructureConstraint] = None,
                    use_cache:bool = True,
                    **kwargs) -> Structure:
    """Protocol for placing a ligand into an enzyme in an unoptimized manner. Operates directly on the Structure and Ligand objects,
    and returns a new, deep-copied Structure object with the placed ligand. The Chain, residue index, and ligand name must be specified
    through the new_res_key Tuple with layout (chain, idx, name). The ligand placement strategy is specified with the 'method' keyword.
    Note that additional arguments and key word arguments are not explained in detail/validated in this method, but in the child methods
    that are called during the ligand placement progress.

    Args:
        stru: Structure that the Ligand() will be placed within.
        ligand: Ligand() to be placed.
        new_res_key: Name of the new residue as a Tuple with format (chain, index, name).
        method: How the ligand will be placed in the Structure. Defaults to 'alphafill'
        work_dir: Where the work will be done and temporary files will be saved. Defaults to system.SCRATCH_DIR
        constraints: A List[RosettaCst] objects. Optional.
        use_cache: Should we used existing results when present?


    Returns:
        A deepcopied Structure() which contains the new Ligand() at the specified location.
    """
    if not work_dir:
        work_dir = config['system.SCRATCH_DIR']

    fs.safe_mkdir(work_dir)

    placed_ligand: str = None

    if method == "alphafill":
        _place_alphafill(stru, ligand_chain, ligand_idx, work_dir=work_dir, **kwargs)
    elif method == "mole2":
        _place_mole2(stru, ligand_chain, ligand_idx, constraints=constraints, work_dir=work_dir, **kwargs)
    else:
        _LOGGER.error(
            f"The supplied method placement method {method} is not supported. Allowed methods are 'alphafill' and 'mole2'. Exiting..."
        )
        exit(1)


def _place_mole2(stru:Structure,
                    ligand_chain:str,
                    ligand_idx:int,
                    constraints:List[StructureConstraint],
                    work_dir:str,
                    delta:float = 0.75, 
                    **kwargs) -> Ligand:
    """Implementation function that places a specified ligand into a structure using the cavities generated by
    the Mole2 topological analysis software. SHOULD NOT be called directly by the user. Instead, call 
    `enzy_htp.preparation.place_ligand.place_ligand()`. Selection of a cavity is based on whether 1) the cavity
    is capable of holding the Ligand() and 2) if the Ligand() is in a favorable geometry as defined by the 
    supplied RosettaCst constraints.

    Args:
        stru: Structure() where teh Ligand() will be added. 
        ligand: The Ligand() object that is being placed.
        constraints: A List[RosettaCst] that define the geometry involving the Ligand().
        new_res_key: Tuple specifying the (chain, idx, name) of the Ligand().
        work_dir: Directory where all temporary files will be saved.
        float: TODO(CJ)

    Returns:
        An aligned, deecopied Ligand().
    """
    #TODO(CJ): rotate the ligand in the cavity
    #TODO(CJ): check how many atoms fit in the molecule

    ligand:Ligand = stru.get(f"{ligand_chain}.{ligand_idx}")
    ligand.placement_method = "mole2"
    if not work_dir:
        work_dir = config['system.SCRATCH_DIR']

    relevant_constraints: List[str] = list()
    
    temp_pdb:str=f"{work_dir}/__temp.pdb"
    to_delete:List[str] = [ temp_pdb ]

    parser = PDBParser()
    parser.save_structure( temp_pdb, stru )
    cavities:List[Mole2Cavity] = interface.mole2.identify_cavities(temp_pdb)

    seed_locations:List = list()
    for cc in cavities:
        vert_matrix = np.array(cc.points())
        (x_min, y_min, z_min) = np.min(vert_matrix,axis=0)
        (x_max, y_max, z_max) = np.max(vert_matrix,axis=0)
        contained_points = list()
        x_vals = list(np.arange(x_min, x_max+delta, delta))
        y_vals = list(np.arange(y_min, y_max+delta, delta))
        z_vals = list(np.arange(z_min, z_max+delta, delta))
        
        candidates = list()
        for x in x_vals:
            for y in y_vals:
                for z in z_vals:
                    candidates.append(np.array([x, y, z]))
        candidates = np.array(candidates)
        for included, cp in zip(cc.contains_points(candidates), candidates):
            if included:
                seed_locations.append(cp)


    seed_locations = np.array(seed_locations)
    scores = list()

    for sl in seed_locations:
        #TODO(CJ): this is where I put the actual energy/constraint evaluation
    
        lig_start = ligand.geom_center
        shift = sl - lig_start

        ligand.shift(shift)

        curr_energy = 0.0
        for cst in constraints:
            if cst.is_residue_pair_constraint():
                curr_energy += interface.rosetta.score_energy(cst.distanceAB_)
            #TODO(CJ): add in the regular distance constraints
                
        scores.append( curr_energy )            

    scores = np.array(scores)

    score_mask = np.isclose(scores, np.min(scores))

    clash_counts = list()
    for sl in seed_locations[score_mask]:
        lig_start = ligand.geom_center
        shift = sl - lig_start

        ligand.shift(shift)
        clash_ct = 0

        for res in stru.residues:
            if res == ligand:
                continue
            clash_ct += res.clash_count( ligand )
    
        clash_counts.append( clash_ct ) 

    clash_counts = np.array(clash_counts)

    clash_mask = np.isclose(clash_counts, np.min(clash_counts))

    final_locations = seed_locations[score_mask][clash_mask]
    seed = final_locations[0]

    ligand.shift( seed - ligand.geom_center)


def _place_alphafill(stru: Structure,
                    ligand_chain:str,
                    ligand_idx:int,
                     work_dir: str,
                     #similarity_cutoff: float = 0.75,
                     clash_radius: float = 2.0, #TODO(CJ); get rid of this
                     **kwargs) -> Ligand:
    """Implementation function that places a specified ligand into a structure using the alphafill 
    algorithm (https://doi.org/10.1038/s41592-022-01685-y). SHOULD NOT be called directly by the user. 
    Instead, call `enzy_htp.preparation.place_ligand.place_ligand()`. Assumes that the input Ligand() has PDB style naming 
    and is in the .mol2 format. When scanning alphafill transplants, the algorithm looks for exact atom label
    matches. If none are found, then a similarity score is calculated which is:

    intersection(candidate atoms, template atoms) / max( number candidate atoms, number template atoms )

    Args:
        stru: Structure() where the Ligand() will be added.
        ligand: The Ligand() object that is being placed.
        work_dir: Directory where all temporary files will be saved.
        similarity_cutoff: How similar a Ligand() and template must be to get considered.
        clash_radius: Radius cutoff (Angstroms) for clash counting between two heavy atoms.

    Returns:
        An aligned, deepcopied Ligand().
    """
    ligand:Ligand = stru.get(f"{ligand_chain}.{ligand_idx}")
    ligand.placement_method = "alphafill"
    _LOGGER.info(f"Beginnning placement of ligand {ligand} into the structure...")
    _LOGGER.info(f"Calling out to AlphaFill to fill structure...")

    structure_start:str=f"{work_dir}/__afill_temp.pdb"
    fs.safe_rm(structure_start)

    similarity_cutoff:float = kwargs.get('similarity_cutoff', 0.60)

    parser = PDBParser()
    parser.save_structure(structure_start, stru)
    
    to_delete:List[str] = list()

    session = interface.pymol.new_session()
    interface.pymol.general_cmd(session, [
        ('load', structure_start),
        ('remove', f'chain {ligand_chain} and resi {ligand_idx}'),
        ('save', structure_start, 'polymer.protein'),
        ('delete', 'all')
    ])

    lines:List[str]=fs.lines_from_file(structure_start)

    for lidx, ll in enumerate(lines): #epic fix
        lines[lidx] = ll[0:76]

    fs.write_lines(structure_start, lines)

    (filled_structure, transplant_info_fpath) = interface.alphafill.fill_structure(structure_start,use_cache=kwargs.get('use_cache',False))
    _LOGGER.info("Filled structure using AlphaFill!")
    
    transplant_info = json.load(open(transplant_info_fpath, 'r'))
   
    transplant_data = defaultdict(list)
    for hit in transplant_info['hits']:
        identity = hit['identity']
        for tt in hit['transplants']:
            transplant_data['analogue_id'].append( tt['analogue_id'] )
            transplant_data['identity'].append( identity )
            transplant_data['asym_id'].append( tt['asym_id'] )
            transplant_data['clash_count'].append(tt['clash']['clash_count'])
    
    df = pd.DataFrame(transplant_data)
    #TODO(CJ): add logging and actually use the similarity_cutoff 
    memo = dict()
    atom_names:List[List[str]] = list()
    for i, row in df.iterrows():
        if len(row.analogue_id) <= 2:
            atom_names.append(set([row.analogue_id]))
            continue
        temp_file:str = interface.pymol.fetch(row.analogue_id, out_dir=work_dir)
        to_delete.append( str(Path(temp_file).absolute()) )
        if row.analogue_id not in memo:
            interface.pymol.general_cmd(session, [('load', temp_file)])
            memo[row.analogue_id] = set(interface.pymol.collect(session, 'memory', 'name'.split())['name'].to_list())
            interface.pymol.general_cmd(session, [('delete', 'all')])

        atom_names.append(memo[row.analogue_id])

    df['atom_names'] = atom_names
   
    ligand_atoms:Set[str]=set([aa.name for aa in ligand.atoms])
    
    similarity_score:List[float] = list()
    for i, row in df.iterrows():
        numerator:int=len(row.atom_names.intersection(ligand_atoms))
        denominator:int=max(len(ligand_atoms), len(row.atom_names))
        similarity_score.append(numerator/denominator)

    df['similarity_score'] = similarity_score
    similarity_mask = df.similarity_score >= similarity_cutoff

    if not similarity_mask.sum():
        _LOGGER.error(f"No transplants exist with similarity_cutoff of {similarity_cutoff:.3f}! Exiting...")
        exit( 1 )
    
    df = df[similarity_mask].reset_index(drop=True)
    similarity = df.similarity_score.to_numpy()
    df = df[np.isclose(similarity, np.max(similarity))].reset_index(drop=True)

    df.sort_values(by='clash_count',inplace=True)
    selected_id:str=df.asym_id[0]

    molfile:str=f"{work_dir}/__temp.pdb"
    reactant:str=f"{work_dir}/__temp_ligand.mol2"
    template:str=f"{work_dir}/__template_ligand.mol2"
    outfile:str=f"{work_dir}/__aligned_ligand.mol2"
    to_delete.extend([molfile, reactant, template, outfile, structure_start, filled_structure, transplant_info_fpath])

    parser.save_structure(molfile, stru)

    Mol2Parser().save_ligand(reactant, ligand)
    
    pp_chains:List[str] = list()
    for cc in stru.chains:
        if cc.is_polypeptide():
            pp_chains.append(f"chain {cc.name}")

    interface.pymol.general_cmd(session, [('delete', 'all'), ("load", filled_structure), ("remove", "solvent"), ("load", molfile),
                                          ("align", f"{Path(filled_structure).stem} and ({' or '.join(pp_chains)})", f"{Path(molfile).stem} and ({' or '.join(pp_chains)})"),
                                          ("delete", Path(molfile).stem),
                                          ("save", template, f"chain {selected_id} and segi {selected_id}")])

    outfile:str=align_ligand(template, reactant, outfile=outfile)
    aligned_ligand:Ligand=Mol2Parser().get_ligand(outfile)
    
    for a1 in ligand.atoms:
        for a2 in aligned_ligand.atoms:
            if a1.name == a2.name:
                a1.coord = a2.coord

    for td in to_delete:
        fs.safe_rm( td )

