"""Provides functionality for placing a ligand into a protein. All functionalty should be accessed through 
the place_ligand() function. No other function should be called directly by users. Allows for placement of 
ligands via one of the below methods:

    + alphafill: Uses the AlphaFill transplant algorithm to identify a location for a given ligand. Works best
    for common bi-molecular co-factors (i.e. SAM, ATP, etc). Assumes PDB style atom naming.
    
    + mole2: Uses cavities identified by the Mole2 software suite to identify possible locations for a given 
    Ligand. Ranks possible locations/orientations using supplied geomtry constraints. Works best for non-co-factor
    substrates. More neutral to atom naming than alphafill.

Author: Chris Jurich <chris.jurich@vanderbit.edu>
Date: 2023-09-14
"""
import json
from typing import List, Tuple, Dict, Set

from rdkit import Chem as _rchem
import numpy as np
import pandas as pd
import enzy_htp as eh
from pathlib import Path
from copy import deepcopy
from collections import defaultdict

from enzy_htp import interface, config
from enzy_htp.core import file_system as fs

from enzy_htp.core import _LOGGER

import enzy_htp.chemical as chem
from enzy_htp.structure import PDBParser, Structure, Ligand, Mol2Parser, Chain
from enzy_htp._interface import RosettaCst, Mole2Cavity

from .align_ligand import align_ligand
from .constrained_docking import constrained_docking

def place_ligand(stru : Structure,
                 ligand: Ligand,
                 new_res_key: Tuple[str, int, str],
                 method: str = 'alphafill',
                 work_dir: str = None,
                 constraints: List[RosettaCst] = None,
                 use_cache:bool = True,
                 **kwargs) -> Structure:
    """Protocol for placing a ligand into an enzyme in an unoptimized manner. Operates directly on the Structure and Ligand objects,
    and returns a new, deep-copied Structure object with the placed ligand. The Chain, residue index, and ligand name must be specified
    through the new_res_key Tuple with layout (chain, idx, name). The ligand placement strategy is specified with the 'method' keyword.
    Note that additional arguments and key word arguments are not explained in detail/validated in this method, but in the child methods
    that are called during the ligand placement progress.

    Args:
        stru: Structure that the Ligand() will be placed within.
        ligand: Ligand() to be placed.
        new_res_key: Name of the new residue as a Tuple with format (chain, index, name).
        method: How the ligand will be placed in the Structure. Defaults to 'alphafill'
        work_dir: Where the work will be done and temporary files will be saved. Defaults to system.SCRATCH_DIR
        constraints: A List[RosettaCst] objects. Optional.
        use_cache: Should we used existing results when present?


    Returns:
        A deepcopied Structure() which contains the new Ligand() at the specified location.
    """
    if len(new_res_key) != 3 or len(new_res_key[-1]) != 3:
        _LOGGER.error(f"The new_res_key expects a tuple of size 3 with layout (chain name, index, residue name). Exiting...")
        exit( 1 )

    if not work_dir:
        work_dir = config['system.SCRATCH_DIR']

    fs.safe_mkdir(work_dir)

    placed_ligand: str = None

    if method == "alphafill":
        placed_ligand = _place_alphafill(stru, ligand, work_dir=work_dir, **kwargs)
    elif method == "mole2":
        placed_ligand = _place_mole2(stru, ligand, constraints=constraints, new_res_key=new_res_key, work_dir=work_dir, **kwargs)
    else:
        _LOGGER.error(
            f"The supplied method placement method {method} is not supported. Allowed methods are 'alphafill' and 'mole2'. Exiting..."
        )
        exit(1)
    
    #TODO(CJ): QZ made a better way to insert a residue. Do that
    placed_ligand.name = new_res_key[2]
    placed_ligand.idx = new_res_key[1]
        
    for cc in stru.chains:
        if cc.name == new_res_key[0]:
            cc.add_residue( placed_ligand )
            return deepcopy( stru )
    else:        
        copied_chains = [deepcopy(cc) for cc in stru.chains]
        new_chain = Chain(new_res_key[0], [placed_ligand])
        return Structure( copied_chains + [new_chain])

def _place_mole2(stru:Structure,
                    ligand:Ligand,
                    constraints:List[RosettaCst],
                    new_res_key:Tuple,
                    work_dir:str,
                    delta:float = 0.75, 
                    **kwargs) -> Ligand:
    """Implementation function that places a specified ligand into a structure using the cavities generated by
    the Mole2 topological analysis software. SHOULD NOT be called directly by the user. Instead, call 
    `enzy_htp.preparation.place_ligand.place_ligand()`. Selection of a cavity is based on whether 1) the cavity
    is capable of holding the Ligand() and 2) if the Ligand() is in a favorable geometry as defined by the 
    supplied RosettaCst constraints.

    Args:
        stru: Structure() where teh Ligand() will be added. 
        ligand: The Ligand() object that is being placed.
        constraints: A List[RosettaCst] that define the geometry involving the Ligand().
        new_res_key: Tuple specifying the (chain, idx, name) of the Ligand().
        work_dir: Directory where all temporary files will be saved.
        float: TODO(CJ)

    Returns:
        An aligned, deecopied Ligand().
    """
    #TODO(CJ): rotate the ligand in the cavity
    #TODO(CJ): check how many atoms fit in the molecule
    if not work_dir:
        work_dir = config['system.SCRATCH_DIR']

    relevant_constraints: List[str] = list()
    
    #TODO(CJ): probably need to deepcopy these
    for cc in constraints:
        if cc.contains(new_res_key[0], new_res_key[1]):
            relevant_constraints.append(cc)

    for rc in relevant_constraints:
        rc.remove_constraint('angle_A')
        rc.remove_constraint('angle_B')
        rc.remove_constraint('torsion_A')
        rc.remove_constraint('torsion_B')
        rc.remove_constraint('torsion_AB')

    anchors = list()        
    for rc in relevant_constraints:
        anchors.append(rc.other(new_res_key[0], new_res_key[1]))

    temp_pdb:str=f"{work_dir}/__temp.pdb"
    to_delete:List[str] = [ temp_pdb ]

    parser = PDBParser()
    parser.save_structure( temp_pdb, stru )
    cavities:List[Mole2Cavity] = interface.mole2.identify_cavities(temp_pdb)

    seed_locations:List = list()
    for cc in cavities:
        vert_matrix = np.array(cc.points())
        (x_min, y_min, z_min) = np.min(vert_matrix,axis=0)
        (x_max, y_max, z_max) = np.max(vert_matrix,axis=0)
        contained_points = list()
        x_vals = list(np.arange(x_min, x_max+delta, delta))
        y_vals = list(np.arange(y_min, y_max+delta, delta))
        z_vals = list(np.arange(z_min, z_max+delta, delta))
        
        candidates = list()
        for x in x_vals:
            for y in y_vals:
                for z in z_vals:
                    candidates.append(np.array([x, y, z]))
        candidates = np.array(candidates)
        for included, cp in zip(cc.contains_points(candidates), candidates):
            if included:
                seed_locations.append(cp)
   
    stru_cpy = deepcopy(stru)
    stru_cpy.add(ligand, chain_name=new_res_key[0] ) #TODO(CJ): get some logic in here about the available chains
    best_energy:float = None 
    best_point:Tuple[float,float,float] = None
    
    for sl in seed_locations:
        #TODO(CJ): this is where I put the actual energy/constraint evaluation
    
        lig_start = ligand.geom_center
        shift = sl - lig_start

        ligand.shift(shift)
        
        curr_energy = 0.0
        for rc in relevant_constraints:
            curr_energy += sum(rc.evaluate(stru_cpy))

        if best_energy is None or curr_energy <= best_energy:
            best_energy = curr_energy
            best_point = sl


    ligand.shift( best_point - ligand.geom_center)

    return ligand


def _place_alphafill(stru: Structure,
                     ligand: Ligand,
                     work_dir: str,
                     #similarity_cutoff: float = 0.75,
                     clash_radius: float = 2.0, #TODO(CJ); get rid of this
                     **kwargs) -> Ligand:
    """Implementation function that places a specified ligand into a structure using the alphafill 
    algorithm (https://doi.org/10.1038/s41592-022-01685-y). SHOULD NOT be called directly by the user. 
    Instead, call `enzy_htp.preparation.place_ligand.place_ligand()`. Assumes that the input Ligand() has PDB style naming 
    and is in the .mol2 format. When scanning alphafill transplants, the algorithm looks for exact atom label
    matches. If none are found, then a similarity score is calculated which is:

    intersection(candidate atoms, template atoms) / max( number candidate atoms, number template atoms )

    Args:
        stru: Structure() where the Ligand() will be added.
        ligand: The Ligand() object that is being placed.
        work_dir: Directory where all temporary files will be saved.
        similarity_cutoff: How similar a Ligand() and template must be to get considered.
        clash_radius: Radius cutoff (Angstroms) for clash counting between two heavy atoms.

    Returns:
        An aligned, deepcopied Ligand().
    """
    _LOGGER.info(f"Beginnning placement of ligand {ligand} into the structure...")
    _LOGGER.info(f"Calling out to AlphaFill to fill structure...")

    structure_start:str=f"{work_dir}/__afill_temp.pdb"

    similarity_cutoff:float = kwargs.get('similarity_cutoff', 0.60)

    parser = PDBParser()
    parser.save_structure(structure_start, stru)

    (filled_structure, transplant_info_fpath) = interface.alphafill.fill_structure(structure_start)
    _LOGGER.info("Filled structure using AlphaFill!")
    
    transplant_info = json.load(open(transplant_info_fpath, 'r'))
   
    transplant_data = defaultdict(list)
    for hit in transplant_info['hits']:
        identity = hit['identity']
        for tt in hit['transplants']:
            transplant_data['analogue_id'].append( tt['analogue_id'] )
            transplant_data['identity'].append( identity )
            transplant_data['asym_id'].append( tt['asym_id'] )
            transplant_data['clash_count'].append(tt['clash']['clash_count'])
    
    df = pd.DataFrame(transplant_data)
    #TODO(CJ): add logging and actually use the similarity_cutoff 
    memo = dict()
    session = interface.pymol.new_session()
    atom_names:List[List[str]] = list()
    for i, row in df.iterrows():
        if len(row.analogue_id) <= 2:
            atom_names.append(set([row.analogue_id]))
            continue
        temp_file:str = interface.pymol.fetch(row.analogue_id, out_dir=work_dir)
        if row.analogue_id not in memo:
            interface.pymol.general_cmd(session, [('load', temp_file)])
            memo[row.analogue_id] = set(interface.pymol.collect(session, 'memory', 'name'.split())['name'].to_list())
            interface.pymol.general_cmd(session, [('delete', 'all')])

        atom_names.append(memo[row.analogue_id])

    df['atom_names'] = atom_names
   
    ligand_atoms:Set[str]=set([aa.name for aa in ligand.atoms])
    
    similarity_score:List[float] = list()
    for i, row in df.iterrows():
        numerator:int=len(row.atom_names.intersection(ligand_atoms))
        denominator:int=max(len(ligand_atoms), len(row.atom_names))
        similarity_score.append(numerator/denominator)

    df['similarity_score'] = similarity_score
    similarity_mask = df.similarity_score >= similarity_cutoff

    if not similarity_mask.sum():
        _LOGGER.error(f"No transplants exist with similarity_cutoff of {similarity_cutoff:.3f}! Exiting...")
        exit( 1 )
    
    df = df[similarity_mask].reset_index(drop=True)
    similarity = df.similarity_score.to_numpy()
    df = df[np.isclose(similarity, np.max(similarity))].reset_index(drop=True)

    df.sort_values(by='clash_count',inplace=True)
    selected_id:str=df.asym_id[0]

    molfile:str=f"{work_dir}/__temp.pdb"
    reactant:str=f"{work_dir}/__temp_ligand.mol2"
    template:str=f"{work_dir}/__template_ligand.mol2"
    outfile:str=f"{work_dir}/__aligned_ligand.mol2"
    to_delete:List[str] = [molfile, reactant, template, outfile]

    PDBParser().save_structure(molfile, stru)

    Mol2Parser().save_ligand(reactant, ligand)

    interface.pymol.general_cmd(session, [('delete', 'all'), ("load", filled_structure), ("remove", "solvent"), ("load", molfile),
                                          ("align", Path(filled_structure).stem, Path(molfile).stem),
                                          ("delete", Path(molfile).stem),
                                          ("save", template, f"chain {selected_id} and segi {selected_id}")])

    outfile:str=align_ligand(template, reactant, outfile=outfile)
    aligned_ligand:Ligand=Mol2Parser().get_ligand(outfile)

    for td in to_delete:
        fs.safe_rm( td )

    return aligned_ligand

