"""Define functions for mutate Structure(). 
Science API:
    +mutate_stru()
    +assign_mutation()

Mutation is carried out by an underlying engine and the supported engines currently include:
    + Amber/tleap

Author: Qianzhen (QZ) Shao <shaoqz@icloud.com>
Date: 2022-10-24
"""

from typing import List
from enzy_htp.structure import Structure
from .mutation import Mutation, is_valid_mutation
from .mutation_pattern import decode_mutation_pattern

def mutate_stru(
    stru: Structure,
    mutation_list: List[Mutation],
    engine: str = "tleap_min",
    in_place: bool=False,
) -> Structure:
    """
    This science API solves the problem of protein structural prediction upon mutation.
    It means to determine which mutation to address and determine the structure of the
    mutant of the source protein caused by residue substitution, deletion, and insertion.
    (see also: structure_prediction module for an alternative solution)
    Args:
        stru: the target structure
        mutation_list: a target list of mutation objects. (normally generated by the assign
            mutation function)
        engine: the engine (method) used for determine the mutated structure
            (current available keywords):
            tleap_min
            # TODO may need to add more arg when deletion and insertion are supported
            # (e.g.: engine_del, engine_ins)
        in_place: if change the structure in-place and return the reference
                  False means return a changed structure_obj and keep the original object
                  intact
                  (default is False since wild-type structure is expected to also available
                  in many applications)
    Raises:
        enzy_htp.core.exception.UnsupportedMethod if the supplied engine is not supported.
    Returns:
        the reference/copy of the changed structure (depends on the in_place value)

    Details:
        Unlike predicting the whole protein structure from sequence and smiles, mutating a
    structure from a reference structure involves only changes on a limit number of residues
    and perturbation of the rest of the structure (especially ligand binding, protonation state etc.)
    As a result, it can be solved using more efficient methods and predicting the whole structure
    from sketch. Note that the accuracy of the resulting structure varies base on the need. If followed
    by MD, the structure only needs to be good starting point of MD.
        There are 3 types of mutations in protein sequence: substitution, deletion, and insertion.
        Substitution is the most common type of the mutation. In this case, only the side-chain is
    replaced by another type of the side-chain. And determining the conformation of the new side-chain
    is the main challenge. It also relates to side-chain conformation prediction in the field of
    structural prediction.
        Deletion and insertion involve backbone changes.

    Avaible strageties:
    Substitution:
        Direct replacement of the side-chain:
        - tleap_min (https://pubs.acs.org/doi/full/10.1021/acs.jcim.1c01424)
            The most simple way to get a mutant structure. It 1. place the new side-chain using a
            constant conformation (relative to backbone) and 2. relax the crude mutant structure using
            MM minimization.

            Consider limited change of other side chains in MM minimization
            Not consider backbone change

            * This method particularly has problem when mutating a small residue to a larger one. In this
            case, collision may appears in the mutated structure and the MM minimization is responsible
            for resolving it. But in extreme cases, there are unresolvable collision such as the carbon
            chain is trapped in a phenyl ring. And currently we don't have a method to detect such trapping.
            The method is only used as a place holder for 1st version EnzyHTP. We have encounter any problem
            brought by the accuracy of the mutation when using this method in workflows but users should be
            cautious with it and consider it a potential source of absured results.
        
        Side-chain rotamer library:
        (most used in the field)
        - SCWRL4 (http://dunbrack.fccc.edu/lab/scwrl)
            Not consider other side-chain change
            Not consider backbone change
        - PyMol (https://github.com/schrodinger/pymol-open-source)
            Not consider other side-chain change
            Not consider backbone change
        - Phyre2
            Consider other side-chain change
            Not consider backbone change
            * seems having a derived pipeline Missense3D addressing the challenge (https://www.sciencedirect.com/science/article/pii/S0022283619302037?via%3Dihub#s0050)
            * related discussion in its website (http://www.sbg.bio.ic.ac.uk/phyre2/html/help.cgi?id=help/faq)

        Machine learning methods:
        - Packpred (http://cospi.iiserpune.ac.in/packpred/, https://www.frontiersin.org/articles/10.3389/fmolb.2021.646288/full, https://github.com/kuanpern/PackPred)
          * find a summary of the missence mutation in the intro of the paper
            Unknown

        MCMC search globally in side-chains:
        - Modeller
            Fully consider other side-chain change
            Not consider backbone change
        - SWISSMODEL
            Fully consider other side-chain change
            Not consider backbone change

    Insertion/Deletion:
        - Phyre4
            see http://www.sbg.bio.ic.ac.uk/phyre2/html/help.cgi?id=help/faq
            works mainly <5 AA change
    """
    assert is_valid_mutation(stru, mutation_list)


def assign_mutation(
    stru: Structure,
    pattern: str,
    chain_sync_list: List[tuple],
    random_state: int = 100,
) -> List[List[Mutation]]:
    """
    This science API assigns mutants targeted in the study.
    decode the user assigned {pattern} based on the {stru} and get a list of mutants defined by
    a list of mutation objects each.

    Args:
        stru: the target structure
        pattern: the pattern that defines the mutation (see syntax below)
        chain_sync_list: a list like [(A,C),(B,D)] to indicate homo-chains in enzyme ploymer
            (like dimer). Mutations will be **copied** to the correponding homo-chains as it
            is maybe experimentally impossible to only do mutations on one chain of a homo-dimer
            enzyme.
        random_state: The int() seed for the random number generator. Default value is 100.

    Raises:
        enzy_htp.core.exception.InvalidMutationPatternSyntax
    Return:
        a list of mutants defined each by a list of mutation objects.

    *Pattern Syntax:*
        "mutant_1,mutant_2,mutant_3,..."
        The top layer of the mutation_pattern specify mutants with comma seperated patterns
        In the pattern of each mutant, there could be more than one sections, but if multiple
        sections are used, {} is needed to group those sections.
        "{section_a1,section_a2,section_a3},{section_b1,section_b2,section_b3},..."
        Each section can be one of the format below:
        1. direct indication                    : XA###Y
        2. random M, N-point mutation in a set  : r:N[mutation_set_patterns]*M
        3. all mutation in a set: a             : a:[mutation_set_patterns]

        The mutation_set_patterns is seperated by comma and each describes 2 things:
        1. position_pattern: a set of positions
                            (using the selection syntax in the selection module)
        2. target_aa_pattern: a set of target mutations apply to all positions in the current set
                            (using syntax in the target_aa_pattern module)
        The two pattern are seperated by ":" and a mutation_set_patterns looks like:
        "position_pattern_0:target_aa_pattern_0, ..."

        Overall an example of pattern will be:
        "{RA154W, DA11G}, r:2[resi 289 around 4 and not resi 36:larger, proj(id 1000, id 2023, positive, 10):more_negative_charge]*100"
        * here proj() is a hypothetical selection function

    Details:
        Which mutations should we study is a non-trivial question. Mutations could be assigned
    from a database or a site-saturation requirement. It reflexs the scientific question defined
    Assigning the mutation requires converting chemical/structural language to strict mutation
    definitions. Some fast calculations can also be done during the selection of mutations. (e.g.:
    calculating residues aligned with the projection line of the reacting bond [ref])
        There are no existing software besides EnzyHTP addressing this challenge.
        A language that helps user to assign mutations is defined above.
    """
    # decode the pattern
    mutation_objs = decode_mutation_pattern(stru, pattern)
    # sync over polymers
    mutation_objs = sync_mutation_over_chains(mutation_objs, chain_sync_list)
    # san check of the mutation_flagss
    assert is_valid_mutation(stru, mutation_objs)

    return mutation_objs
